---
title: "이진 탐색"
date: "2023-01-14"
description: "이진 탐색 알고리즘에 대해서 알아보자!"
---

## 이진 탐색의 특징

1. 반드시 정렬이 되어있어야 사용할 수 있다.
2. 배열 혹은 이진 트리를 이용하여 구현할 수 있다.
3. O(logn) 시간복잡도인 만큼 상당히 빠르다

### 배열을 이용한 이진 탐색 방법

배열의 맨 왼쪽이 left, 가운데가 mid 맨 오른쪽이 right라고 할 때

- mid = (left + right) / 2
- right = mid -1
- left = mid +1
  이라고 한다.

### 이진 탐색 트리

이진 탐색을 위한 이진 트리로 왼쪽 서브 트리는 루트보다 작은 값이 모여있고, 오른쪽 서브 트리는 루트보다 큰 값이 모여있다.

- 값 추가하기

5  
4-7  
2-5 6-8

5가 root인 트리 구조를 통해 각 정점 마다 자신 보다 큰것은 오른쪽  
자신 보다 작은 값은 왼쪽 정점으로 추가한다.

- 단말 정점을 삭제하는 경우

  - 별다른 처리 없이 보무 정점과 연결을 끊으면 된다.

- 하나의 서브 트리를 가지는 경우

  - 제거되는 정점의 부모 간선을 자식 정점을 가르키게 바꾸면 된다.

- 두개의 서브 트리를 가지는 경우
  - 왼쪽 서브 트리의 가장 큰 값 혹은 오른쪽 서브 트리의 가장 작은 값과 교체하면 된다.
  - 이 경우 교체된 정점의 좌우 자식이 없다면 제거되는 정점의 링크로 대체된다.

### 이진 탐색 트리의 문제점

- 최악의 경우 한쪽으로 편향된 트리가 될 수 있다.
- 그런 경우 순차 탐색과 동일한 시간복잡도를 가진다.
- 이를 해결하기 위해 다음과 같은 자료구조를 이용할 수 있다.
  - AVL 트리
  - 레드-블랙 트리

### 자바스크립트에서 사용법

1. Array

```js
const array = [1, 1, 5, 124, 400, 599, 1004, 2876, 8712];

function binarySearch(array, findValue) {
  let left = 0;
  let right = array.length - 1;
  let mid = Math.floor((left + right) / 2);
  while (left < right) {
    if (array[mid] === findValue) {
      return mid;
    }
    if (array[mid] < findValue) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  mid = Math.floor((left + right) / 2);
}
```

2. Binary Search Tree
