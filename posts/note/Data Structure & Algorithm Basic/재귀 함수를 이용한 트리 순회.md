---
title: "재귀 함수를 이용한 트리 순회"
date: "2023-01-23"
description: "재귀 함수를 이용한 트리 순회에 대해서 알아보자!"
---

## 재귀 함수를 이용한 트리 순회 알고리즘이란?

트리 순회는 트리 자료구조에서 각 노드를 한 번씩 탐색하는 알고리즘을 말합니다. 이 트리 순회는 여러 방법이 있지만 재귀를 이용할 수 있는 순회는 전위 순회(Preorder), 중위 순회(Inorder), 후위 순회(Postorder)가 있습니다. 모든 순회는 루트 노드부터 시작하며 어떤 노드를 먼저 방문하는지가 달라집니다. 여기서는 이진 트리를 이용하여 설명드리겠습니다.

### 전위 순회

전위 순회는 (1)먼저 노드를 방문한 후 (2)왼쪽 서브 트리를 전위 순회한 다음에 (3)오른쪽 서브 트리를 전위 순회하는 방식을 의미합니다. 다음과 같은 이진 트리가 있다고 가정 해보겠습니다.

```
    1
   / \
  /   \
  2    \
 / \    3
4   5  / \
      6   \
           7
          / \
         8   9
```

위 트리에서 전위 순회는 다음과 같이 동작합니다.

1. 우선 1을 방문합니다.
2. 1의 왼쪽 서브 트리로 이동합니다.
3. 2를 방문합니다.
4. 2의 왼쪽 서브 트리로 이동합니다.
5. 4를 방문합니다.
6. 왼쪽, 오른쪽 서브 트리가 없기에 다시 올라갑니다.
7. 2의 오른쪽 서브 트리로 이동합니다.
8. 5를 방문합니다.
9. 왼쪽, 오른쪽 서브 트리가 없기에 다시 올라갑니다.
10. 왼쪽, 오른쪽 서브 트리를 모두 방문했기에 다시 올라갑니다.
11. 1의 오른쪽 서브 트리로 이동합니다.
12. 3을 방문합니다.
13. 3의 왼쪽 서브 트리로 이동합니다.
14. 6을 방문합니다.
15. 왼쪽, 오른쪽 서브 트리가 없기에 다시 올라갑니다.
16. 3의 오른쪽 서브 트리로 이동합니다.
17. 7을 방문합니다.
18. 7의 왼쪽 서브 트리로 이동합니다.
19. 8을 방문합니다.
20. 왼쪽, 오른쪽 서브 트리가 없기에 다시 올라갑니다.
21. 7의 오른쪽 서브 트리로 이동합니다.
22. 9를 방문합니다.
23. 모든 트리를 순회했기에 종료됩니다.
    최종적으로 1, 2, 4, 5, 3, 6, 7, 8, 9 노드 순으로 방문을 하게됩니다. 이를 의사 코드로 나타내자면

```js
preorder(tree) {
방문(tree.root);
preorder(tree.left);
preorder(tree.right);
}
```

으로 표현 할 수 있습니다.

### 중위 순회

전위 순회는 (1)왼쪽 서브 트리를 중위 순회한 후 (2)노드를 방문한 다음에 (3)오른쪽 서브 트리를 중위 순회하는 방식을 의미합니다. 다음과 같은 이진 트리가 있다고 가정 해보겠습니다.

```
    1
   / \
  /   \
  2    \
 / \    3
4   5  / \
      6   \
           7
          / \
         8   9
```

위 트리에서 중위 순회는 다음과 같이 동작합니다.

1. 1의 왼쪽 서브 트리로 이동합니다.
2. 2의 왼쪽 서브 트리로 이동합니다.
3. 더 이상 왼쪽 서브 트리가 없어 4를 방문합니다.
4. 4의 오른쪽 서브 트리가 없기에 올라갑니다.
5. 2를 방문합니다.
6. 2의 오른쪽 서브 트리로 이동합니다.
7. 더 이상 왼쪽 서브 트리가 없어 5를 방문합니다.
8. 5의 오른쪽 서브 트리가 없기에 올라갑니다.
9. 2에서 왼쪽, 오른쪽 서브 트리를 모두 방문했기에 다시 올라갑니다.
10. 1을 방문합니다.
11. 1의 오른쪽 서브 트리로 이동합니다.
12. 3의 왼쪽 서브 트리로 이동합니다.
13. 더 이상 왼쪽 서브 트리가 없어 6을 방문합니다.
14. 6의 오른쪽 서브 트리가 없기에 올라갑니다.
15. 3을 방문합니다.
16. 3의 오른쪽 서브 트리로 이동합니다.
17. 7의 왼쪽 서브 트리로 이동합니다.
18. 더 이상 왼쪽 서브 트리가 없어 8을 방문합니다.
19. 8의 오른쪽 서브 트리가 없기에 올라갑니다.
20. 7을 방문합니다.
21. 7의 오른쪽 서브 트리로 이동합니다.
22. 더 이상 왼쪽 서브 트리가 없어 9를 방문합니다.
23. 모든 트리를 순회했기에 종료됩니다.
    최종적으로 4, 2, 5, 1, 6, 3, 8, 7, 9 노드 순으로 방문을 하게됩니다. 이를 의사 코드로 나타내자면

```js
inorder(tree) {
inorder(tree.left);
방문(tree.root);
inorder(tree.right);
}
```

으로 표현 할 수 있습니다.

### 후위 순회

전위 순회는 (1)왼쪽 서브 트리를 후위 순회한 후 (2)오른쪽 서브 트리를 후위 순회한 다음에 (3)노드를 방문하는 방식을 의미합니다. 다음과 같은 이진 트리가 있다고 가정 해보겠습니다.

```
    1
   / \
  /   \
  2    \
 / \    3
4   5  / \
      6   \
           7
          / \
         8   9
```

위 트리에서 후위 순회는 다음과 같이 동작합니다.

1.  1의 왼쪽 서브 트리로 이동합니다.
2.  2의 왼쪽 서브 트리로 이동합니다.
3.  더 이상 왼쪽, 오른쪽 서브 트리가 없어 4를 방문합니다.
4.  올라갑니다.
5.  2의 오른쪽 서브 트리로 이동합니다.
6.  더 이상 왼쪽, 오른쪽 서브 트리가 없어 5를 방문합니다.
7.  모든 서브 트리를 방문하였기에 2를 방문합니다.
8.  올라갑니다.
9.  1의 오른쪽 서브 트리로 이동합니다.
10. 3의 왼쪽 서브 트리로 이동합니다.
11. 더 이상 왼쪽, 오른쪽 서브 트리가 없어 6을 방문합니다.
12. 올라갑니다.
13. 3의 오른쪽 서브 트리로 이동합니다.
14. 7의 왼쪽 서브 트리로 이동합니다.
15. 더 이상 왼쪽, 오른쪽 서브 트리가 없어 8을 방문합니다.
16. 올라갑니다.
17. 7의 오른쪽 서브 트리로 이동합니다.
18. 더 이상 왼쪽, 오른쪽 서브 트리가 없어 9를 방문합니다.
19. 올라갑니다.
20. 더 이상 왼쪽, 오른쪽 서브 트리가 없어 7을 방문합니다.
21. 올라갑니다.
22. 더 이상 왼쪽, 오른쪽 서브 트리가 없어 3을 방문합니다.
23. 올라갑니다.
24. 더 이상 왼쪽, 오른쪽 서브 트리가 없어 1을 방문합니다.
    최종적으로 4, 5, 2, 6, 8, 9, 7, 3, 1 노드 순으로 방문을 하게됩니다. 이를 의사 코드로 나타내자면

```js
postorder(tree) {
postorder(tree.left);
postorder(tree.right);
방문(tree.root);
}
```

으로 표현 할 수 있습니다.

구현 코드
이런 전위, 중위, 후위 순회에 대한 재귀 코드 구현은 다음과 같습니다.

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class Tree {
  constructor(node) {
    this.root = node;
  }

  preorder(currentNode) {
    // 전위 순회
    console.log(currentNode.value);
    if (currentNode.left) this.preorder(currentNode.left);
    if (currentNode.right) this.preorder(currentNode.right);
  }

  inorder(currentNode) {
    // 중위 순회
    if (currentNode.left) this.inorder(currentNode.left);
    console.log(currentNode.value);
    if (currentNode.right) this.inorder(currentNode.right);
  }

  postorder(currentNode) {
    // 후위 순회
    if (currentNode.left) this.postorder(currentNode.left);
    if (currentNode.right) this.postorder(currentNode.right);
    console.log(currentNode.value);
  }
}

const tree = new Tree(new Node(9));
tree.root.left = new Node(3);
tree.root.right = new Node(8);
tree.root.left.left = new Node(2);
tree.root.left.right = new Node(5);
tree.root.right.right = new Node(7);
tree.root.left.right.right = new Node(4);

tree.preorder(tree.root);
tree.inorder(tree.root);
tree.postorder(tree.root);
```
